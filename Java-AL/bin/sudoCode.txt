N(도시 개수)
W[i][j](i 도시에서 j 도시로 가는 데 드는 비용을 저장하는 배열)
D[c][v]: 현재 도시가 c, 현재까지 방문한 모든 도시 리스트가 v일 때 앞으로 남은 모든 도시를 경유하는 데 필요한 최소 비용

for(i -> 0 ~ N){
    for(j -> 0 ~ N){
        W 배열에 값 저장하기
    }
}

for(i -> 0 ~ N){
    for(j -> 0 ~ 1 << N){
        D배열을 충분히 큰 수로 저장하기
    }
} 

tsp(0, 1)
정답 출력하기

tsp(c, v){
    if(모든 도시를 방문할 때)
    {
        시작 도시로 돌아갈 수 있을 때 -> return W[c][시작 도시]
        시작 도시로 돌아갈 수 없을 때 -> return 무한대
    }
    if(이미 계산한 적이 있을 때) return D[c][v]
    for(i -> 0 ~ N){
        if(방문한 적이 없고, 갈 수 있는 도시일 때){
            d[c][v] = Math.min(d[c][v], tsp(i, (v | (1 << i))) + W[c][i]);
        }
    }

    return d[c][v]
}