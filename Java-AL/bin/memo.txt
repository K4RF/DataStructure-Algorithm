N(도시 수), M(도로 수)
A(도시 인접 리스트) reverseA(역방향 인접 리스트)
도시 수만큼 인접 리스트 초기화하기
진입 차수 배열 초기화하기
for(도로 수만큼 반복하기){
    인접 리스트 데이터 저장하기
    역방향 인접 리스트 데이터 저장하기
    진입 차수 배열 초기 데이터 저장하기
}

큐 생성하기
출발 도시를 큐에 삽입하기
result(각 도시의 최대 걸리는 시간 저장 - 임계 경로값)
while(큐가 빌 때까지){
    현재 노드 = 큐에서 데이터 poll
    for(현재 노드에서 갈 수 있는 노드의 개수){
        타깃 노드 진입 차수 배열--
        result = 타깃 노드의 현재 경로 값과 현재 노드의 경로값 + 도로 시간값 중 큰 값으로 저장하기
        if(타깃 노드의 진입 차수가 0이면) 큐에 타깃 노드 추가하기
    }
}
visited(각 도시의 방문 유무 저장하기)
resultCount(1분도 쉬지 않고 달려야 하는 도로의 수)
도착 도시를 큐에 삽입하기
visited 배열에 도착 도시를 방문 도시로 표시하기
while(큐가 빌 때까지){
    현재 노드 = 큐에서 데이터 poll
    for(현재 노드에서 갈 수 있는 노드의 개수 -> 역방향 인접 리스트 기준){
        if(타깃 노드의 result값 + 도로를 걸리는 데 지나는 시간(엣지) == 현재 노드의 result값){
            1분도 쉬지 않고 달려야 하는 도로값 1 증가
            if(아직 방문하지 않은 도시이면){
                visited 배열에 방문 도시 표시하기
                큐에 타깃 노드 추가하기
            }
        }
    }
}

만나는 시간(result[endDosi]) 출력
1분도 쉬지 않고 달려야 하는 도로의 수(resultCount) 출력