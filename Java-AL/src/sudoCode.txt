N(도시 개수) M(노선 개수)
distance(노선 데이터를 저장하는 인접 행렬)

for(i -> N만큼 반복하기){
    for(j -> N만큼 반복하기){
        시작 도시와 종료 도시가 같으면 0, 아니면 충분히 큰 수로 저장하기
    }
}

for(M만큼 반복하기){
    노선 데이터를 distance 행렬에 저장하기
}
for(k -> N만큼 반복하기){
    for(i -> N만큼 반복하기){
        for(j -> N만큼 반복하기){
            distance[i][j]에 distance[i][k] + distance[k][j] 값들 중 최솟값 넣기
            i ~ j 사이에 가능한 모든 경로를 탐색하기
        }
    }
}
정답 배열 출력하기 -> 만약 정답 배열의 값이 최초 초기화하기에 충분한 큰 수일 경우에는 도착할 수 없는 경로이기 때문에 0을 출력 아니면 거리 배열 값 출력하기