dr, dc(네 방향 탐색을 위한 상수)
N, M(행렬의 크기)
map(맵 정보 저장 배열)
parent(대표 노드 저장 배열)
visited(BFS를 할 때 방문 여부 저장 배열)
sumlist(모든 섬 정보 저장하기)
mlist(1개의 섬 정보 저장하기)
queue(다리 정보를 저장할 우선순위 큐)
for(N만큼 반복하기){
    for(M만큼 반복하기){
        입력데이터를 map 변수에 저장하기
    }
}
for(i -> N만큼 반복하기){
    for(j -> M만큼 반복하기){
        BFS(i, j) 모든 위치에서 BFS를 실행해 섬을 분리하기
        결과를 sumlist 변수에 넣기
    }
}

for(i -> sumlist 크기만큼 반복하기){
    now <- sumlist에서 추출
    for(j -> now 크기만큼 반복하기){
        1개의 섬의 모든 위치에서 만들 수 있는 다리 정보 저장하기
    }
}

parent(대표 노드 저장 배열)
대표 노드 저장 배열을 값을 자신의 index로 초기화하기

while(큐가 빌 떄까지){
    큐에서 엣지 정보 가져오기엣지 시작점과 끝점의 부모 노드가 다르면 -> 연결해도 사이클이 생기지 않으면 union 연산 수행하기
    엣지의 가중치를 정답 변수에 더하기
}
사용한 엣지가 노드 개수 - 1만큼이면 가중치의 합을 결과로 출력하기
아니면 -1 출력하기

union(a, b){
    a와 b의 대표 노드 찾기
    두 원소의 대표 노드끼리 연결하기
}
find(a){
    a가 대표 노드면 리턴하기
    아니면 a의 대표 노드 값을 find(parent[a]) 값으로 저장 -> 재귀 함수 형태
}
BFS(i, j){
    i, j 위치에서 네 방향을 탐색해 1개 섬의 영역을 저장하기
}
bEdge implements Comparable{
    s(출발 노드), e(종료 노드), v(가중치)
    가중치의 오름차순 정렬되도록 구현하기
}