N(유저 수) M(친구 관계 수)
distance(친구 관계 데이터를 저장하는 인접 행렬)
for(i -> N만큼 반복하기){
    for(j -> N만큼 반복하기){
        시작 도시와 종료 도시가 같으면 0, 아니면 충분히 큰 수로 저장하기
    }
}

for(M만큼 반복하기){
    친구 관계 데이터를 distance 행렬에 저장하기
    친구 관계는 서로 관계를 맺는 것이므로 양방향 엣지로 저장하고 가중치를 1로 함
}

for(k -> N만큼 반복하기){
    for(i -> N만큼 반복하기){
        for(j -> N만큼 반복하기){
            distance[i][j]에 distance[i][k] + distance[k][j] 값들 중 최솟값 넣기
            i ~ j 사이에 가능한 모든 경로를 탐색하기
        }
    }
}

MIN(충분히 큰 수로 초기화){
    for(i -> N만큼 반복하기){
        for(j -> N만큼 반복하기){
            각 배열의 값을 합치기 -> i의 케빈 베이컨 수
        }
        if(MIN > i의 케빈 베이컨 수) MIN 값을 i의 케빈 베이컨의 수로 저장하기
    }
}
가장 작은 케빈 베이컨수를 지니고 있는 i 출력하기