tree(인접 리스트 자료구조)
N(수의 개수), M(질의 개수)
depth(노드 깊이 배열) parent(노드 조상 배열)
visited(방문 여부 저장하기 배열)

for(N의 개수만큼 반복하기){
    tree 인접 리스트의 각 ArrayList 초기화
}

for(N - 1의 개수만큼 반복하기){
    tree 인접 리스트에 그래프 데이터 저장하기
}

kmax(최대 가능 높이) 구하기
parent 크기 선언하기 -> [kmax + 1][N + 1]
BFS(1)

for(kmax 만큼 반복하기){
    for(노드 개수 만큼 반복하기){
        점화식을 이용해 parent 구성하기 -> parent[k][n] = parent[k-1][parent[k-1][n]]
    }
}

for(M의 개수만큼 반복하기){
    a(1번 노드), b(2번 노드)
    excuteLCA(a와 b의 LCA를 구하는 함수 호출 및 결괏값 출력하기)
}

excuteLCA(1번 노드, 2번 노드){
    1번 노드가 depth가 더 작으면 1번 노드와 2번 노드 swap
    두 노드의 depth를 동일하게 맞추기(a를 부모 노드로 변경을 높이가 맞을 때까지 반복하기)
    두 노드의 같은 조상이 나올 떄까지 각 노드를 부모 노드로 변경하는 작업을 반복하기
    최소 공통 조상 리턴하기
}

BFS{
    큐 자료구조에 출발 노드 더하기(add 연산)
    visited 배열에 현재 노드 방문 기록하기
    whiel(큐가 빌 떄까지){
        큐에서 노드 데이터를 가져오기(poll 연산)
        현재 노드의 연결 노드 중 방문하지 않은 노드로 반복하기{
            큐에 데이터 삽입(add 연산)하고 visted 배열에 방문 기록하기
            parent 배열에 자신의 부모 노드 저장하기
            depth 배열에 현재 높이 저장하기
        }
        if(이번 높이에 해당하는 모든 노드를 방문했을 떄){
            현재 배열의 depth를 1개 증가
        }
    }
}